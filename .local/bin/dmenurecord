#!/bin/bash

# Usage:
# `$0`: Ask for recording type via dmenu
# `$0 screencast`: Record both audio and screen
# `$0 video`: Record only screen
# `$0 audio`: Record only audio
# `$0 kill`: Kill existing recording
#
# If there is already a running instance, user will be prompted to end it.
# https://trac.ffmpeg.org/wiki/Encode/H.264

set -euo pipefail

die() {
	setsid -f notify-send "${0##*/}" "$*" &
	echo "$*" >&2
	exit 1
}

if ! xrandr | grep -qF 'connected primary'; then
	die "No primary display assigned"
fi

dest_dir=$(xdg-user-dir VIDEOS)
readonly dest_dir
if [[ -z $dest_dir ]] || [[ ! -d $dest_dir ]] ; then
	die "Can't find the Videos directory."
fi

screen_resolution() {
	# first monitor only
	xrandr | grep -Po 'connected primary \K[^ ]*?(?=\+)'
}

getdim() { xrandr | grep -oP '(?<=current ).*(?=,)' | tr -d ' ' ;}

notify_end() { notify-send "$(basename -- "$0")" "Stopped recording."; }

updateicon() {
	echo "$1" >/tmp/recordingicon
	pkill -RTMIN+9 "${STATUSBAR:-i3blocks}"
}

timestamp() {
	date -u '+%Y-%b-%d_%H-%M-%S'
}

killrecording() {
	recpid="$(cat -- /tmp/recordingpid)"
	if [[ -z $recpid ]]; then
		return
	fi
	# kill with SIGTERM, allowing finishing touches.
	if kill -15 "$recpid"; then notify_end; fi
	rm -f -- /tmp/recordingpid
	updateicon ""
	# even after SIGTERM, ffmpeg may still run, so SIGKILL it.
	sleep 3
	if kill -9 "$recpid"; then notify_end; fi
	exit
}

trim_spaces() {
	sed 's/^ *//g; s/ *$//g;'
}

find_monitor() {
	pactl list sources |
		grep -i -B 1 -P 'Description:.*monitor.*speaker|Description: Monitor of Built-in Audio Analog Stereo' |
		cut -d: -f2 |
		head -1 |
		trim_spaces
}

find_microphone() {
	pactl list sources |
		grep -i -B 1 -P 'Description:.*digital microphone' |
		cut -d: -f2 |
		head -1 |
		trim_spaces
}

__ffmpeg() {
	local -r input=${1:?}
	local -r video_resolution=${2:?}
	local -r output=${3:?}

	# Run `pactl list sources`
	local -r PA_MONITOR=$(find_monitor)
	local -r PA_MIC=$(find_microphone)

	local -a inputs=()
	if [[ -n $PA_MONITOR ]]; then
		inputs+=(  -f pulse -thread_queue_size 1024 -i "$PA_MONITOR"  )

	else
		die "Monitor wasn't found."
	fi
	if [[ -n $PA_MIC ]]; then
		inputs+=(  -f pulse -thread_queue_size 1024 -i "$PA_MIC"  )
		inputs+=(  -filter_complex "[1:a][2:a]amix=inputs=2:duration=longest:dropout_transition=0[aout]"   )
		inputs+=( -map "[aout]"  )
	else
		inputs+=( -map "1:a"  )
	fi

	exec ffmpeg -y \
		-f x11grab \
		-framerate 30 \
		-s "$video_resolution" \
		-i "$input" \
		-use_wallclock_as_timestamps 1 \
		"${inputs[@]}" \
		-map 0:v \
		-r 30 \
		-c:v libx264 \
		-crf 10 \
		-preset ultrafast \
		-c:a aac \
		-b:a 256k \
		-ac 2 \
		-qp 0 \
		-profile:v baseline \
		-movflags +faststart \
		-pix_fmt yuv420p \
		-vf "pad=ceil(iw/2)*2:ceil(ih/2)*2" \
		"$output"
}

screen_offset() {
	xrandr | grep -Po 'connected primary [^ ]*?\+\K[^ ]*' | sed 's/+/,/'
}

screencast() {
	__ffmpeg "$DISPLAY+$(screen_offset)" "$(screen_resolution)" "$dest_dir/screencast-$(timestamp).mp4" &
	echo $! >/tmp/recordingpid
	updateicon "‚è∫Ô∏èüéôÔ∏è"
}

selected_area() {
	set -x
	read -r X Y W H <<<"$(slop -f "%x %y %w %h")"
	__ffmpeg "${DISPLAY}+${X},${Y}" "${W}x${H}" "$dest_dir/screencast-area-$(timestamp).mp4" &
	echo $! >/tmp/recordingpid
	updateicon "‚è∫Ô∏èüéôÔ∏è"
}

video() {
	ffmpeg \
		-an \
		-f x11grab \
		-framerate 30 \
		-s "$(screen_resolution)" \
		-i "$DISPLAY" \
		-c:v libx264 \
		-qp 0 \
		-r 30 \
		-pix_fmt yuv420p \
		-vf "pad=ceil(iw/2)*2:ceil(ih/2)*2" \
		-movflags +faststart \
		-profile:v baseline \
		"$dest_dir/video-$(timestamp).mkv" &
	echo $! >/tmp/recordingpid
	updateicon "‚è∫Ô∏è"
}

webcamhidef() {
	ffmpeg \
		-f v4l2 \
		-i /dev/video0 \
		-s 1920x1080 \
		"$dest_dir/webcam-$(timestamp).mkv" &
	echo $! >/tmp/recordingpid
	updateicon "üé•"
}

webcam() {
	ffmpeg \
		-f v4l2 \
		-i /dev/video0 \
		-s 640x480 \
		"$dest_dir/webcam-$(timestamp).mkv" &
	echo $! >/tmp/recordingpid
	updateicon "üé•"
}

audio() {
	FILE_PATH="$dest_dir/audio-$(timestamp).flac"
	ffmpeg \
		-f alsa -i default \
		-c:a flac \
		"${FILE_PATH:?}" &
	echo $! >/tmp/recordingpid
	updateicon "üéôÔ∏è"
}

audio_anki() {
	ankiconnect_request() {
		curl --silent localhost:8765 -X POST -d "${1:?}"
	}
	store_file() {
		local -r path=${1:?} name=${2:?}
		local request='{
			"action": "storeMediaFile",
			"version": 6,
			"params": {
				"filename": "<name>",
				"path": "<path>"
			}
		}'
		request=${request/<name>/$name}
		request=${request/<path>/$path}
		ankiconnect_request "$request"
	}
	workdir="/tmp/audacity"

	mkdir "$workdir"
	cd "$workdir" || return 1

	audio

	# While ffmpeg is running...
	wait

	audacity "${FILE_PATH:?}"

	if ! ls ./*.*; then return; fi
	cm ftogg

	local audiofiles bn path
	for file in ./*.ogg; do
		bn=$(basename -- "$file")
		path=$(readlink -f -- "$file")
		audiofiles="${audiofiles}[sound:$bn]"
		store_file "$path" "$bn"
	done
	rm -rf -- "$workdir"
	printf "%s" "$audiofiles" | xclip -selection clipboard
	rm -- "${FILE_PATH:?}"
}

dmenu_recording_style() {
	cat <<-EOF | dmenu -l 30 -i -p "Select recording style:"
		screencast
		video
		audio
		audio+add to anki
		webcam
		webcam (hi-def)
		selected area
	EOF
}

askrecording() {
	case "$(dmenu_recording_style)" in
	'screencast') screencast ;;
	'video') video ;;
	'audio') audio ;;
	'audio+add to anki') audio_anki ;;
	'webcam') webcam ;;
	'webcam (hi-def)') webcamhidef ;;
	'selected area') selected_area ;;
	esac
}

asktoend() {
	local -r response=$(printf "No\\nYes" | dmenu -i -p "Recording still active. End recording?")
	if [[ "$response" = "Yes" ]]; then
		killrecording
	fi
}

case "${1-}" in
screencast) screencast ;;
audio) audio ;;
video) video ;;
selected*) selected_area ;;
kill) killrecording ;;
*)
	if [[ -f /tmp/recordingpid ]]; then
		asktoend
		exit
	else
		askrecording
	fi
	;;
esac
